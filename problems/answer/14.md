# ANSWER SECTION 14

* __`01`__ 判断元素在浏览器的位置
  * getBoundingClientRect
* __`02`__ vue双向数据绑定原理，vue3废弃了什么，优化了什么
  * tree-shaking技术，能够在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果
  * 监听不到对象属性的增删、数组元素和长度的变化
  * 2.x的机制导致作用域插槽变了，父组件会重新渲染，而3.0把作用于插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
  * 修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript的结合变得很容易
* __`03`__ http1.0到1.1的区别   1.1到2.0的区别
  <!-- https://www.cnblogs.com/heluan/p/8620312.html -->
  * 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
  * HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。
  * 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
  * 多路复用（MultiPlexing），即连接共享，HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
  * header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
  * 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。
* __`04`__ 虚拟dom是怎么是实现的，虚拟dom的diff算法如何实现 渲染节点的顺序
* __`05`__ 1亿条数据里，取前1千条最大的数据
* __`06`__ proxy实现原理，写了一个数据劫持的方法
* __`07`__ BFC的实现场景，脱离文档流的好处
  * FC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素
  * 只要元素满足下面任一条件即可触发BFC特性
    * body 根元素
    * 浮动元素：float 除 none 以外的值
    * 绝对定位元素：position (absolute、fixed)
    * display 为 inline-block、table-cells、flex
    * overflow 除了 visible 以外的值 (hidden、auto、scroll)
* __`08`__ 移动端和pc端遇到过的兼容问题
* __`09`__ 同时发出三批Ajax请求，然后对都请求到的数据依次处理  async/await
* __`10`__ ready 完成后怎么判断是否执行DomContentLoaded事件
# ANSWER SECTION 1

* __`01`__ 怎么去设计一个组件封装
  * 组件封装的目的是为了重用，提高开发效率和代码质量
  * 低耦合，单一职责，可复用性，可维护性
  * 组件化是对实现的分层，是更有效地代码组合方式
  * 组件化有利于单元测试
  * 组件化对重构较友好
* __`02`__ js异步加载的方式
  * XHR Injection(XHR 注入)
    * 通过XMLHttpRequest来获取JavaScript，然后创建一个script元素插入到DOM结构中。ajax请求成功后设置script.text为请求成功后返回的responseText。
  * defer属性
    * IE4.0就出现。defer属声明脚本中将不会有document.write和dom修改。浏览器会并行下载其他有defer属性的script。而不会阻塞页面后续处理。注：所有的defer脚本必须保证按顺序执行的
  * async属性
    * Html5新属性。脚本将在下载后尽快执行，作用同defer，但是不能保证脚本按顺序执行。他们将在onload事件之前完成。
* __`03`__ css 动画和 js 动画的差异
  <!-- https://www.cnblogs.com/shuaishuaidejun/p/7444711.html -->
  * 性能
  * 代码复杂度
  * 控制能力
  * 动画的丰富度
  * 兼容性问题
  * 如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css动画是优选方案
  * 如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的 APP。那么你应该使用js动画，这样你的动画可以保持高效，并且你的工作流也更可控。
* __`04`__ XSS 与 CSRF 两种跨站攻击
  * XSS 跨站脚本攻击(Cross-site scripting)
    * 攻击者利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码
    * 如何防范
      * 没有过滤掉恶意代码的动态内容被发送给web用户。
  * CSRF 跨站点请求伪造(Cross—Site Request Forgery)
    * 攻击者盗用了你的身份，以你的名义发送恶意请求
    * 攻击原理及过程
      * 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
      * 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
      * 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
      * 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
      * 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站   A 并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代      码被执行
    * 防范过程
      * 验证 HTTP Referer 字段
        * 它记录了该 HTTP 请求的来源地址
      * 在请求地址中添加 token 并验证
        * 可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。
        * 黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击
      * 在 HTTP 头中自定义属性并验证
        * 通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token值放入其中

* __`05`__ cookie token jwt
  <!-- https://www.cnblogs.com/xiekeli/p/5607107.html -->
  * cookie
    * cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。
  * token
    * Token机制相对于Cookie机制的优势
      * 支持跨域访问
      * 无状态
        * Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.
      * CSRF
      * 性能
        * 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.
  * jwt
    * JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。
    * 载荷（Payload）
      * 载荷是一个JSON对象进行[base64编码]得到的字符串
    * 头部（Header）
      * 头部是一个JSON对象进行[base64编码]得到的字符串
    * 签名（Signature）
      * 将上面的两个编码后的字符串都用句号.连接在一起（头部在前）用HS256算法和后端秘钥进行加密
* __`06`__ 字符编码与字符集
  * 字符编码是定义在字符集上的映射规则
  * 常见的编码字符集
    * Unicode
      * 也叫统一字符集，它包含了几乎世界上所有的已经发现且需要使用的字符
    * ASCII
      * 早期的计算机系统只能处理英文，所以ASCII也就成为了计算机的缺省字符集，包含了英文所需要的所有字符。
    * GB2312
      * 中文字符集，包含ASCII字符集。ASCII部分用单字节表示，剩余部分用双字节表示
  * 常见的字符编码
    * ASCII
      * 既是编码字符集，又是字符编码
    * UTF-8
* __`07`__ 事件委托
  * ![事件流](../assets/1/event-flow.png '事件流')
  * 把一个或者一组元素的事件委托到它的父层或者更外层元素上
  * 优点，减少内存消耗，动态绑定事件
  * target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)
* __`08`__ 线程 进程
  * 线程是最小的执行单元，进程是最小的资源管理单元
  * 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程
* __`09`__ 负载均衡
  * 当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力
  * 基于DNS
    * DNS服务器配置多个A记录，不同的DNS请求会解析到不同的IP地址。大型网站一般使用DNS作为第一级负载均衡。
      缺点是DNS生效时间略长，扩展性差
  * 基于IP报文
    * 早期比较有代表性并且被大量使用的的就是LVS了。原理是LVS在Linux内核态获取到IP报文后，根据特定的负载均衡算法将IP报文转   发到整个集群的某台服务器中去。缺点是LVS的性能依赖Linux内核的网络性能，但Linux内核的网络路径过长导致了大量开销，使得    LVS单机性能较低。
* __`10`__ 前端缓存
  <!-- https://blog.csdn.net/lu123535884/article/details/51489951 -->
  * 关于是否缓存，是浏览器缓存还是CDN缓存，缓存保留多长时间，由cache-control控制
    * Cache-control: public 表示缓存的版本可以被代理服务器或者其他中间服务器识别（浏览器，cdn都能缓存）。
    * Cache-control: private 意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允    许缓存（只能用户的浏览器缓存）。
    * Cache-control: no-cache 意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用，因为同样的URL，对应的内容会   发生变化
    * Last-Modified: 服务器为了通知浏览器当前文件的版本，会发送一个上次修改时间的标签
  * 浏览器缓存
    <!-- https://www.cnblogs.com/shixiaomiao1122/p/7591556.html -->
    * ![浏览器缓存](../assets/1/browser-catch.png '浏览器缓存')
    * 强缓存
      * 用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
    * 协商缓存
      * 用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。
    * 两者共同点
      * 客户端获得的数据最后都是从客户端缓存中获得
    * 两者的区别
      * 从名字就可以看出，强缓存不与服务器交互，而协商缓存则需要与服务器交互
    * expires
      * 表明过期时间
      * 存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差  
    * Cache-Control
      * ![Cache-Control](../assets/1/cache-control.png 'Cache-Control')
      * 可以看成是 expires 的补充。使用的是相对时间的概念。
    * 协商缓存
      * Last-modified: 表明请求的资源上次的修改时间。
      * If-Modified-Since：客户端保留的资源上次的修改时间。
      * Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可）
      * If-None-Match： 客户端保留的资源内容标识。
        * 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。
        * 分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败
  * cdn缓存
    * cdn缓存就是在浏览器和服务器间增加的一层缓存，缓存一些html、图片、css、xml等静态资源
      * 客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是    否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束;如果数据已经过期，那么CDN还需要向源站发出回源请   求(back to the source request),来拉取最新的数据。
      * 原理
        * 通过动态域名解析，网友的请求被分配到离自己最快的服务器。CDN服务器直接返回缓存文件或通过专线代理原站的内容。
          网络加速+内容缓存，有效提供访问速度
      * CDN缓存内容的更新
        * 用户首次请求，CDN从原站抓取后缓存，直到文件过期后有用户请求再次更新
        * 程序主动通知CDN抓取
    * 动态域名解析
      * 将用户的动态IP地址映射到一个固定的域名解析服务(服务商主机上的服务器程序)上, 捕获用户每次变化的IP地址，然后将其与域   名相对应，这样域名就可以始终解析到非固定IP的服务器上，互联网用户通过本地的域名服务器获得网站域名的IP地址，从而可以    访问网站的服务。
# ANSWER SECTION 5

* __`01`__ meta的viewport属性
  * width=device-width,
    * 窗口自动调整到设备宽度  
  * initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,
    * 禁止用户缩放页面
  * viewport-fit=cover
    * 使页面占满整个屏幕
* __`02`__ 前端开发的难点到底在什么地方
  <!-- https://www.zhihu.com/question/275915023 -->
  * 前端的流程天然割裂，等着后端处理请求时，还要想着法的讨好用户
  * 前端有很多的 state 要管理，除了后端给的数据，各个控件也有 state
  * 前端不易抽象。后端抽象的结果是行为逻辑，前端再怎么抽，最后还是要画出页面
  * 前端提意见的门槛低。后端演示，大家看着黑乎乎的命令行，前端做演示，门口路过的，都能进来指导一下。
  * 前端的最佳实践少。后端的问题往往都有一两种大量实践过的方案，前端遇到了问题，就是八仙过海，各显神通。
  * 前端需求修改多。前端没有对错，只有顺不顺眼，写了改，改了写，大量的时间花在细枝末节，和给框架填坑上。
  * 工程师的职责不是憋着解决技术问题，而是把乱七八糟的开源项目变成可以互相配合契合业务的解决方案
* __`03`__ 移动端的事件有哪些，和PC端有哪些区别
  * 移动端的事件有哪些，和PC端有哪些区别
    * click
    * touchstart,touchmove,touchend
  * 兼容性
    * PC考虑的是浏览器的兼容性
    * 移动端开发考虑的更多的是手机兼容性 一般浏览器使用的都是webkit内核
  * 事件
    * 移动端多出来的事件是触屏事件 缺少的是hover事件。包括移动端弹出的手机键盘的处理
  * 布局
    * 移动端开发一般是要做到布局自适应的，我使用的一直是rem布局
* __`04`__ 移动端的300毫秒延迟是什么 fastclick.js 点透事件
  * 点透事件
    * 当手指触摸到屏幕的时候，系统生成两个事件，一个是touch 一个是click，touch先执行，touch执行完成后，A从文档树上面消失了，而且由于移动端click还有延迟200-300ms的关系，当系统要触发click的时候，发现在用户点击的位置上面，目前离用户最近的元素是B(B在A上面)，所以就直接把click事件作用在B元素上面了
    * 先触发的touch事件去取消系统生成的click事件,只要在touchend事件的某个处理函数中 执行 e.preverDefault即可，
  * 300毫秒
    * 移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动
  * fastclick原理
    * 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。
* __`05`__ 怎么实现getElementsByTagName
* __`06`__ 怎么修改domain
  <!-- https://blog.csdn.net/yuan_zhikong/article/details/76038222 -->
  <!-- https://www.cnblogs.com/dunken/p/4476182.html -->
  * 首先用document.domain来指定域，是可以的，但是有局限性，也就是一级域名一致才可以
* __`07`__ 从零开始选择开发框架、构建工具
* __`08`__ 哪些MVVM框架更适合移动端
  * webApp(vue)
    <!-- https://www.zhihu.com/question/36958272 -->
    * 优秀的ui库(vux, mint)
    * 轻量，灵活，易定制
    * 组件化结合路由可出色的完成SPA应用
    * 模块化开发配合VueX可将复杂的项目碎片化为多层架构，将复杂的项目开发简单化。
  * app
    <!-- https://segmentfault.com/q/1010000012314009 -->
    * React-native的跨平台共用部分，仅仅是UI模块，有80%左右。而且你得有一定的原生app开发能力。
    * Weex这个跟react-native有点类似,也是需要理解一定的原生app
    * Angular，这个有一个hybrid混合模式的ionic。对原生app要求很低，基本都是前端的知识。但是相关文档特别少
* __`09`__ 用户体验日活月活分析
  <!-- https://www.imooc.com/article/27151 -->
  * 为什么要埋点？
    * 现在的互联网公司越来越关注转化、新增、留存，
  * 手动埋点
    * 手写代码 自定义属性 自定义事件
    * 开发成本 更新成本比较大
  * 可视化埋点
    * 可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，这里的配置数据可以设置过滤条件，避免针对所有元素（比如全埋点），可以在调用开启自动监控API时通过设置一些特征属性，来过滤不符合条件的元素，实现只针对某些元素进行自动上报数据的需求。
    * 可视化埋点优化了移动运营中数据采集的流程，能够支持产品运营随时调整埋点，无需再走发版流程，直接把配置结果推入到前端，数据采集流程更简化，也更方便产品的迭代。可视化埋点中多数基于Xpath的方案，XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。
  * 无埋点
    * 只需要简单的加载了一段定义好的SDK代码
    * 前端会自动全量采集全部事件并上报埋点数据，能够呈现用户行为的每一次点击、每一次跳转、每一次登录等全量、实时用户行为数据，这些数据传到后端后，可通过用户分群、漏斗对比等功能，分析不同访问来源、不同城市、不同广告来源等多维度的不同转化细节，细而全。
  * 无埋点和可视化埋点虽然使用和部署都很简单，但是在数据精确度和详细程度的获取能力上代码埋点更强大。
* __`10`__ 内存泄漏分析
  <!-- https://segmentfault.com/a/1190000008901861?_ea=1788166 -->
  * performance的折线图js heap
  * memory的heap snapshot 工具
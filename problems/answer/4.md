# ANSWER SECTION 4

* __`01`__ 进程间的通信
  * 管道
  * 消息队列
  * 信号量
  * 共享内存
* __`02`__ tcp协议的三次握手四次挥手(time-wait  close-wait last-ack)
  <!-- https://blog.csdn.net/qzcsu/article/details/72861891 -->
  * 三次握手
    * TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
    * TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
    * TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
    * TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
    * 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。
    * ![三次握手](../assets/4/tcp-three-handshake.jpg '三次握手')
  * 四次挥手
    * 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
    * 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
    * 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
    * 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
    * 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
    * 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
    * ![四次挥手](../assets/4/tcp-four-wave.jpg '四次挥手')
* __`03`__ get和post的区别
  * get是从服务器上获取数据，post是向服务器传送数据。
  * GET 请求可被缓存 POST 请求不会被缓存
  * 在客户端， get方式在通过URL提交数据，数据在URL中可以看到；post方式，数据放置在HTML BODY内提交
  * get方式提交的数据最多只能有2083字节，而post则没有此限制
  * 对数据类型的限制 get只允许ASCII字符 post没有限制
  * 敏感数据用post 不敏感的数据可以使用get
* __`04`__ tcp和udp的区别
  * TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
  * TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
  * 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
  * UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
* __`05`__ 加载速度优化是如何做的，描述下具体场景
  * 减少HTTP请求
    * 合并脚本和样式表
    * 雪碧图
  * 使用CDN
  * 使用缓存Expires和Cache-Control
  * 对HTTP传输进行压缩(gzip, deflate, sdch)
  * 懒加载(Intersection Observer)
    * 对于一些图片，非首屏的，后面scroll到的时候再加载
  * 按需加载
    * 模块化开发，只需加载用到的资源
    * 优先加载关键的CSS(其他的脚本或者样式表可以动态加载)
  * 预加载
    * 预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。
  * 异步无阻塞加载JS(defer, async)
    * 如果使用defer或async请将Script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。
  * DNS预获取 dns-prefetch 提升页面载入速度
  * 使用预编译
    * 如果您使用单文件组件开发项目，组件会在编译阶段将模板编译为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入vue.min.js，那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能。
  * 服务端渲染（SSR）
    * 单页应用需要等JS加载完毕后在前端渲染页面，也就是说在JS加载完毕并开始执行渲染操作前的这段时间里浏览器会产生白屏。服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。比较推荐的做法是：使用服务端渲染静态HTML来获得更快的首次有效绘制，一旦JavaScript加载完毕再将页面接管下来。
* __`06`__ 写的通用组件弹框，在react的路由结构下，如何做到相对整个浏览器窗口水平垂直居中，而不是相对中后台系统中的右边部分。
* __`07`__ 对前端新技术有哪些了解；
  * grid布局:它可以同时处理列和行
  * Flutter:是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。
  * Parcel：超快的Web应用打包器
  * PWA 渐进式网络应用 ( Progressive Web Apps )
* __`08`__ 对前端工作是怎样理解的，理解中前端的工作是干什么的；
  * 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好
  * 工作流程
    * 立项--项目研讨--需求确认----产品出原型----后台开发同时设计师拿到原型进行UI设计--前端开始开发--测试提bug--改bug--重复n次--产品验收
  * 沟通
    * 界面有问题需要和UI沟通,数据有问题需要和后台沟通,功能有问题需要和产品沟通,测试的时候给你提bug你还需要和测试沟通
    * 深刻理解需求，清楚需求的动机和缘由
    * 换位思考(产品考虑用户体验好不好)
    * 不放过每一个细节
    * 当遇到不合理的需求时，积极寻求替换方案
    * 必须遵循文档精神
    * 对自己的程序有一颗艺术的心
* __`09`__ 手写jQuery的on方法
* __`10`__ 手写jsonp
